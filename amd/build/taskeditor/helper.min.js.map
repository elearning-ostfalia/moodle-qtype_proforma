{"version":3,"file":"helper.min.js","sources":["../../src/taskeditor/helper.js"],"sourcesContent":["// This file is part of ProFormA Question Type for Moodle\n//\n// ProFormA Question Type for Moodle is free software:\n// you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ProFormA Question Type for Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ProFormA Question Type for Moodle.\n// If not, see <http://www.gnu.org/licenses/>.\n\n /**\n * Helper functions\n *\n * @package    qtype\n * @subpackage proforma\n * @copyright  2023 Ostfalia Hochschule fuer angewandte Wissenschaften\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @author     eCULT-Team of Ostfalia University, K.Borm, Dr.U.Priss\n */\n\n// Known bugs: search the code for the string \"ToDo\" below and check faq.html and installationFAQ.html\n\nimport $ from 'jquery';\nimport {FileWrapper, FileStorage, fileStorages} from \"./file\";\nimport {getExtension, setErrorMessage} from \"./util\";\nimport {javaParser} from \"./java\";\nimport {readAndDisplayXml} from \"./task\";\nimport * as Str from 'core/str';\n\n\nexport var readXmlActive = false;\n\nexport function isBinaryFile(file, mimetype) {\n    if (file.name.toLowerCase() === 'makefile') {\n        return false;\n    }\n    if (mimetype && mimetype.match(/(text\\/)/i))  // mimetype is 'text/...'\n        return false;\n\n    const extension = file.name.split('.').pop();\n    switch (extension.toLowerCase()) {\n        case 'c' :\n        case 'h' :\n        case 'cpp' :\n        case 'hpp' :\n        case 'hxx' :\n        case 'cxx' :\n        case 'java' :\n        case 'log' :\n        case 'py' :\n        case 'txt' :\n        case 'xml' :\n        case 'php' :\n        case 'js' :\n        case 'html' :\n        case 'csv' :\n            return false;\n        default: break;\n    }\n    return true;\n}\n\n\nexport function readAndCreateFileData(file, fileId, callback) {\n    if (!file)\n        return;\n    let filename = file.name;\n\n    // check if a file with filename already is stored\n    if (FileWrapper.doesFilenameExist(filename)) {\n        Str.get_string('fileexists', 'qtype_proforma', filename)\n            .then(content => alert(content));\n        return;\n    }\n\n    const size = file.size; //get file size\n    const mimetype = getMimeType(file.type, filename); //get mime type\n    // determine if we have a binary or non-binary file\n    let isBinaryFile = isBinaryFile(file, mimetype);\n    let reader = new FileReader();\n    reader.onload = function (e) {\n        function finishFile(ui_file) {\n            // set filename\n            ui_file.filename = filename;\n\n            /*        if (size > taskeditorconfig.maxSizeForEditor) {\n                        //console.log('file '+ filename + ' is too large => no editor support');\n                        //isBinaryFile = true;\n                    }*/\n\n            if (isBinaryFile) {\n                // binary file\n                // at first update fileStorages because\n                // it is needed for changing file type\n                let fileObject = new FileStorage(isBinaryFile, mimetype, e.target.result, filename);\n                fileObject.setSize(size);\n                fileStorages[ui_file.id] = fileObject;\n                ui_file.type = 'file';\n            } else {\n                // assume non binary file\n                let fileObject = new FileStorage(isBinaryFile, mimetype, 'text is in editor', filename);\n                fileStorages[ui_file.id] = fileObject;\n                ui_file.text = e.target.result;\n                ui_file.type = 'embedded';\n            }\n\n            if (callback)\n                callback(filename, ui_file.id);\n        }\n\n        // special handling for JAVA: extract class name and package name and\n        // recalc filename!\n        if (getExtension(filename) === 'java') {\n            const text = e.target.result;\n            filename = javaParser.getFilenameWithPackage(text, filename);\n        }\n\n        // recheck if a file with that filename already is stored\n        if (FileWrapper.doesFilenameExist(filename)) {\n            Str.get_string('fileexists', 'qtype_proforma', filename)\n                .then(content => alert(content));\n            return;\n        }\n\n        if (!fileId) {\n            // create new file box\n            FileWrapper.createFromTemplate()\n                .then(ui_file => {\n                    finishFile(ui_file);\n                });\n        } else {\n            // file box already exists\n            finishFile(FileWrapper.constructFromId(fileId));\n        }\n    };\n\n    //console.log(\"read file\");\n    if (isBinaryFile)\n        reader.readAsArrayBuffer(file);\n    else\n        reader.readAsText(file);\n}\n\nfunction uploadFilesWhenDropped(files) {\n    $.each(files, function (index, file) {\n        readAndCreateFileData(file, undefined /*-1*/, function (filename) {\n            // nothing extra to be done\n        });\n    });\n}\n\n\n///////////////////////////////////////////////////////// function: readXML\n\nexport function readXMLWithLock (taskXmlText) {\n    readXmlActive = true; // lock automatic input field update\n    try {\n        return readAndDisplayXml(taskXmlText);\n    } catch (err) {\n        setErrorMessage(\"uncaught exception\", err);\n    }\n    finally {\n        readXmlActive = false;\n    }\n}\n\n\n// disable (drag&)drop in whole application except\n// for the intended drop zones\n// (otherwise dropping a file in the browser leaves the editor site)\n\n/*\n    const dropzoneClass = \"drop_zone\";\n    function noDragNDropSupport(e) {\n        if (e.target.class !== dropzoneClass) {\n            e.preventDefault();\n            e.dataTransfer.effectAllowed = \"none\";\n            e.dataTransfer.dropEffect = \"none\";\n        }\n    }\n    window.addEventListener(\"dragenter\", noDragNDropSupport, false);\n    window.addEventListener(\"dragover\", noDragNDropSupport);\n    window.addEventListener(\"drop\", noDragNDropSupport);\n\n    // enable dropping files in the file section\n    // with creating new file boxes\n    var filesection = $(\"#proforma-files-section\").parent();\n    // use parent instead of filesection here because\n    // the acual file section is too small and is not what is expected\n    filesection.on({\n        dragover: function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            //e.dataTransfer.dropEffect = 'copy';\n        },\n        dragenter: function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n        },\n        drop: function (e) {\n            if (e.originalEvent.dataTransfer) {\n                if (e.originalEvent.dataTransfer.files.length) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    //UPLOAD FILES HERE\n                    uploadFilesWhenDropped(e.originalEvent.dataTransfer.files, e.currentTarget);\n                }\n            }\n        }\n    });\n\n    // add file reference for template, library instruction\n    if (USE_VISIBLES)\n        FileReferenceList.init(\"#visiblefiledropzone\", '#visiblesection', VisibleFileReference);\n\n    //FileReferenceList.init(\"#multimediadropzone\", '#multimediasection', MultimediaFileReference);\n    FileReferenceList.init(\"#downloaddropzone\", '#downloadsection', DownloadableFileReference);\n\n    if (!USE_VISIBLES)\n        $(\"#visiblefiledropzone\").hide();\n\n    $(\"#files_restriction\").append(SubmissionFileList.getInstance().getTableString());\n\n*/\n\n///////////////////////////////////////////////////////// end of document ready function\n"],"names":["file","mimetype","name","toLowerCase","match","split","pop","taskXmlText","readXmlActive","err","readAndCreateFileData","fileId","callback","filename","FileWrapper","doesFilenameExist","Str","get_string","then","content","alert","size","getMimeType","type","isBinaryFile","reader","FileReader","onload","e","finishFile","ui_file","fileObject","FileStorage","target","result","setSize","id","text","javaParser","getFilenameWithPackage","constructFromId","createFromTemplate","readAsArrayBuffer","readAsText"],"mappings":";;;;;;;;;8WAuC6BA,KAAMC,aACC,aAA5BD,KAAKE,KAAKC,qBACH,KAEPF,UAAYA,SAASG,MAAM,aAC3B,OAAO,SAEOJ,KAAKE,KAAKG,MAAM,KAAKC,MACrBH,mBACT,QACA,QACA,UACA,UACA,UACA,UACA,WACA,UACA,SACA,UACA,UACA,UACA,SACA,WACA,aACM,SAGR,0FA+FsBI,oCAC7BC,eAAgB,aAEL,2BAAkBD,aAC3B,MAAOE,+BACW,qBAAsBA,oCAGtCD,eAAgB,ovBApIbA,eAAgB,WAiCXE,sBAAsBV,KAAMW,OAAQC,cAC3CZ,KACD,WACAa,SAAWb,KAAKE,QAGhBY,kBAAYC,kBAAkBF,sBAC9BG,IAAIC,WAAW,aAAc,iBAAkBJ,UAC1CK,MAAKC,SAAWC,MAAMD,iBAIzBE,KAAOrB,KAAKqB,KACZpB,SAAWqB,YAAYtB,KAAKuB,KAAMV,cAEpCW,aAAeA,aAAaxB,KAAMC,UAClCwB,OAAS,IAAIC,WACjBD,OAAOE,OAAS,SAAUC,YACbC,WAAWC,YAEhBA,QAAQjB,SAAWA,SAOfW,aAAc,KAIVO,WAAa,IAAIC,kBAAYR,aAAcvB,SAAU2B,EAAEK,OAAOC,OAAQrB,UAC1EkB,WAAWI,QAAQd,yBACNS,QAAQM,IAAML,WAC3BD,QAAQP,KAAO,WACZ,KAECQ,WAAa,IAAIC,kBAAYR,aAAcvB,SAAU,oBAAqBY,6BACjEiB,QAAQM,IAAML,WAC3BD,QAAQO,KAAOT,EAAEK,OAAOC,OACxBJ,QAAQP,KAAO,WAGfX,UACAA,SAASC,SAAUiB,QAAQM,OAKJ,UAA3B,sBAAavB,UAAsB,OAC7BwB,KAAOT,EAAEK,OAAOC,OACtBrB,SAAWyB,iBAAWC,uBAAuBF,KAAMxB,UAInDC,kBAAYC,kBAAkBF,UAC9BG,IAAIC,WAAW,aAAc,iBAAkBJ,UAC1CK,MAAKC,SAAWC,MAAMD,WAI1BR,OAQDkB,WAAWf,kBAAY0B,gBAAgB7B,2BAN3B8B,qBACPvB,MAAKY,UACFD,WAAWC,QAAX,KASZN,aACAC,OAAOiB,kBAAkB1C,MAEzByB,OAAOkB,WAAW3C"}