{"version":3,"file":"zipper.min.js","sources":["../../src/taskeditor/zipper.js"],"sourcesContent":["// This file is part of ProFormA Question Type for Moodle\n//\n// ProFormA Question Type for Moodle is free software:\n// you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ProFormA Question Type for Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ProFormA Question Type for Moodle.\n// If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Helper functions for zipping and unzipping task\n *\n * @package    qtype\n * @subpackage proforma\n * @copyright  2023 Ostfalia Hochschule fuer angewandte Wissenschaften\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @author     eCULT-Team of Ostfalia University, K.Borm, Dr. U.Priss\n */\n\nimport * as zip from \"../zip/zip\";\nimport {FileStorage, FileWrapper, fileStorages } from \"./file\";\nimport {FileReferenceList } from \"./filereflist\";\n\nzip.workerScriptsPath = \"./js/\";\n\nconst debug_unzip = false;\n\nlet unzippedFiles = {};\nlet taskfile_read = false;\n\n/**\n * link files to fileStorages array\n *\n * This must be done after reading all files.\n * Unfortunately file reading is performed asynchrously. So it is not clear\n * in which order the files are read. Because of this the relinkFiles function\n * is called after every processing of a single file in order to guarantee\n * that all files are handled.\n **/\nexport function relinkFiles() {\n    if (!taskfile_read)\n        return; // wait and retry later\n    // if (debug_unzip) console.log(\"relinkFiles \");\n\n    // store not-embedded files in correct location in fileStorages array\n    FileWrapper.doOnAllFiles(function(ui_file) {\n        // if (debug_unzip) console.log(\"relink \" + ui_file.filename + \" type: \" + ui_file.type);\n\n        if (ui_file.type === 'file') {\n            const fileid = ui_file.id; // fileroot.find(\".xml_file_id\").val();\n            const filename = ui_file.filename; //$(item).val();\n            if (unzippedFiles[filename] && !fileStorages[fileid].byZipper) {//!fileStorages[fileid].filename.length) {\n                // note that there is always a fileStorage object whenever there is a ui file object!\n                // file is not yet relinked => link to fileStorage\n                fileStorages[fileid] = unzippedFiles[filename];\n                unzippedFiles[filename] = undefined;\n                // if (debug_unzip) console.log(\"relinkFiles \" + filename + \" -> \" + fileid + \" \" + ui_file.type + \" size: \" + ui_file.size);\n                ui_file.type = ui_file.type; // needed...\n            } else {\n                if (unzippedFiles[filename] && fileStorages[fileid].byZipper) { // fileStorages[fileid].filename.length) {\n                    // consistency check\n                    console.error(\"internal error: file is already relinked! filename \" + filename + \" -> \" + fileid + \" \" + ui_file.type);\n                    alert('internal error: file ' + filename + ' is already relinked!');\n                } else {\n                    /*if (!unzippedFiles[filename])\n                        console.error(\"unzippedFiles[ \" + filename + \"] is missing\");\n                    if (fileStorages[fileid].filename.length)\n                        console.error(\"fileStorages[ \" + fileid + \"] already mapped\");\n                    */\n                }\n            }\n        }\n    });\n\n    // needed because files are read asynchronously\n    FileReferenceList.updateAllEditorButtons();\n}\n\n/**\n * unzips the {task}.zip file\n * - store files temporarily in unzippedFiles\n * - when everything is read then iterate through all fileIds and\n *   move stored files to fileStorages\n *\n * @param blob: zip file object\n * @param location: where to put the 'task.xml'\n * @param readyCallback: callback for 'task.xml' file\n * @returns {string}\n */\nexport function unzipme(blob, readyCallback) {\n    var unzipped_text = \"???\";\n    // dictionary with files (name -> FileStorage)\n    let filesRead = 0;\n    let filesToBeRead = undefined;\n\n    function onFilesRead(zipReader) {\n        relinkFiles();\n        //zipReader.close();\n    }\n\n    function unzipBlob(blob, callbackForTaskXml, callbackForFile) {\n          try {\n              const zipFileReader = new zip.BlobReader(blob);\n              let zipReader = new zip.ZipReader(zipFileReader);\n              console.log('unzip');\n              zipReader.getEntries()\n                  .then(entries => {\n                      filesToBeRead = entries.length;\n                      console.log('filesToBeRead ' + filesToBeRead);\n                      entries.forEach(function(entry) {\n                          // console.log(entry);\n                          console.log('filename: ' + entry.filename);\n                          if (entry.filename === 'task.xml') {\n                              // console.log('unzip task.xml');\n                              const taskXmlWriter = new zip.TextWriter();\n                              entry.getData(taskXmlWriter)\n                                  .then(xmlContent => {\n                                        // if (debug_unzip) console.log('call callback For task.xml');\n                                        callbackForTaskXml(xmlContent);\n                                    });\n                          } else {\n                              // handle attached files'\n                              // console.log('unzip attached file ' + entry.filename);\n                              // store file\n                              const blobWriter = new zip.BlobWriter();\n                              entry.getData(blobWriter)\n                                  .then(data => data.arrayBuffer())\n                                  .then(data => {\n                                      // console.log(data);\n                                      // if (debug_unzip)\n                                      //     console.log('call callbackForFile ' + entry.filename);\n                                      callbackForFile(data, entry);\n                                  });\n                          }\n                      });\n                  })\n                  .catch( error => {\n                      console.error('error:', error);\n                      alert(error);\n                  });\n              zipReader.close();\n\n          } catch(e) {\n              console.error(e);\n          }\n    }\n\n    unzipBlob(blob,\n        // callback for task.xml\n        function (taskXmlContent) {\n            unzipped_text = taskXmlContent;\n            if (readyCallback) {\n                // if (debug_unzip)\n                //     console.log('call readyCallback');\n                readyCallback(taskXmlContent);\n            }\n            // if (debug_unzip)\n            //     console.log('set taskfile_read = true');\n            taskfile_read = true;\n            filesRead++;\n            if (filesRead === filesToBeRead) {\n                onFilesRead();\n            }\n        },\n        // callback for attached files\n        function (unzippedBlob, entry) {\n            // console.log('attached file ' + entry.filename);\n            // console.log(unzippedBlob);\n            // read file header and derive mime type\n            var arr = (new Uint8Array(unzippedBlob)).subarray(0, 4);\n            var header = \"\";\n            for(var i = 0; i < arr.length; i++) {\n                let number = arr[i].toString(16);\n                if (number.length === 1) {\n                    number = '0' + number;\n                }\n                header += number;\n            }\n\n            let type = unzippedBlob.type; // \"unknown\"; // Or you can use the blob.type as fallback\n            switch (header.toLowerCase()) {\n                case '504b0304': type = 'application/zip'; break;\n                case \"25504446\": type = 'application/pdf'; break;\n                case \"89504e47\": type = \"image/png\"; break;\n                case \"47494638\": type = \"image/gif\"; break;\n                case \"ffd8ffe0\":\n                case \"ffd8ffe1\":\n                case \"ffd8ffe2\":\n                case \"ffd8ffe3\":\n                case \"ffd8ffe8\":\n                    type = \"image/jpeg\";\n                    break;\n            }\n\n            // if (debug_unzip) console.log(header + \" => \" + type);\n\n            // store file\n            unzippedFiles[entry.filename] =\n                new FileStorage(true, type, unzippedBlob, entry.filename);\n            unzippedFiles[entry.filename].setZipperFlag();\n            unzippedFiles[entry.filename].setSize(entry.uncompressedSize);\n            filesRead++\n            // if (debug_unzip) console.log('filesRead value: ' + filesRead + ' filesToBeRead=' + filesToBeRead);\n            if (filesRead === filesToBeRead) {\n                onFilesRead();\n            }\n    });\n\n    // return unzipped_text;\n}\n\n\nexport function taskTitleToFilename() {\n\n    function camelize(str) {\n        // code from https://stackoverflow.com/questions/2970525/converting-any-string-into-camel-case\n        return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function(letter, index) {\n            return index === 0 ? letter.toLowerCase() : letter.toUpperCase();\n        }).replace(/\\s+/g, '');\n    }\n    let title = $(\"#id_name\").val();\n    title = camelize(title);\n    // only allow characters, numbers, '-' and '_'\n    title = title.replace(/[^a-z0-9_\\-]/gi, \"_\");\n    title = title + '.zip';\n    return title;\n\n    //return title.replace(/[^a-z0-9]/gi, \"\");\n}\n\n/**\n * create zip file\n */\nexport function zipme(TEXT_CONTENT, startdownload, maxsize) {\n    // get task.xml content from user interface\n    // var TEXT_CONTENT = taskXml; // $(\"#output\").val();\n    if (!TEXT_CONTENT || TEXT_CONTENT.length === 0) {\n        console.error(\"zipme called with empty output\");\n        return;\n    }\n\n    // console.log(TEXT_CONTENT);\n    const FILENAME = \"task.xml\";\n    var blob;\n    const zipname = taskTitleToFilename(); // zipname.replace(/[^a-z0-9]/gi, \"\");\n\n    // iterate through all files:\n    // - if file type is 'file' the file must be added to zip file\n    // - if file is non binary it is stored in the editor!\n    FileWrapper.doOnAllFiles(function(ui_file) {\n    //$.each($(\".xml_file_id\"), function(index, item) {\n        //const ui_file = FileWrapper.constructFromRoot($(item).closest(\".xml_file\"));\n        // let fileroot = $(item).closest(\".xml_file\");\n        // const fileId = fileroot.find(\".xml_file_id\").val();\n        if (!ui_file.type === 'embedded') {\n            // copy editor content to file storage\n            ui_file.storeAsFile = true; // fileStorages[ui_file.id].storeAsFile = true;\n            if (!ui_file.isBinary) {\n                // copy content from editor if file is non binary\n                ui_file.content = ui_file.text;\n                // fileStorages[ui_file.id].content = ui_file.text;\n            }\n        }\n    });\n\n    async function zipBlob(blob) {\n        const zipFileWriter = new zip.BlobWriter(\"application/zip\");\n        const zipWriter = new zip.ZipWriter(zipFileWriter);\n\n        console.log('fileStorages.length is ' + fileStorages.length);\n        let f = 0;\n        while (f < fileStorages.length) {\n            const ui_file = FileWrapper.constructFromId(f);\n            if (ui_file && ui_file.storeAsFile) {\n                let fblob = new Blob([ui_file.content], {type: ui_file.mimetype});\n                console.log('add ' + ui_file.filename + ' to zip file');\n                await zipWriter.add(ui_file.filename, new zip.BlobReader(fblob));\n            }\n            f++;\n        }\n        console.log('add ' + FILENAME + ' to zip file');\n        await zipWriter.add(FILENAME, new zip.BlobReader(blob));\n        await zipWriter.close();\n        return await zipFileWriter.getData();\n    }\n\n    blob = new Blob([ TEXT_CONTENT ], {\n        type : zip.getMimeType(FILENAME)\n    });\n    return zipBlob(blob)\n        .then(zippedBlob => {\n            if (startdownload) {\n                const url = window.URL.createObjectURL(zippedBlob);\n                let a = document.createElement(\"a\");\n                document.body.appendChild(a);\n                a.style = \"display: none\";\n                a.download = zipname;\n                a.href = url;\n                a.click();\n            } else {\n                if (maxsize > 0 && zippedBlob.size > maxsize) {\n                    return Promise.reject('Task size is ' + zippedBlob.size + ' and exceeds maximum size (' + maxsize + ' bytes).\\n' +\n                        'Uploading to the Moodle server is blocked!');\n                } else {\n                    return zippedBlob;\n                }\n            }\n    });\n}"],"names":["blob","readyCallback","filesToBeRead","filesRead","onFilesRead","zipReader","relinkFiles","callbackForTaskXml","callbackForFile","zipFileReader","zip","BlobReader","ZipReader","console","log","getEntries","then","entries","length","forEach","entry","filename","taskXmlWriter","TextWriter","getData","xmlContent","blobWriter","BlobWriter","data","arrayBuffer","catch","error","alert","close","e","unzipBlob","taskXmlContent","taskfile_read","unzippedBlob","arr","Uint8Array","subarray","header","i","number","toString","type","toLowerCase","unzippedFiles","FileStorage","setZipperFlag","setSize","uncompressedSize","TEXT_CONTENT","startdownload","maxsize","zipname","taskTitleToFilename","doOnAllFiles","ui_file","storeAsFile","isBinary","content","text","zipFileWriter","zipWriter","ZipWriter","fileStorages","f","FileWrapper","constructFromId","fblob","Blob","mimetype","add","zipBlob","getMimeType","zippedBlob","size","Promise","reject","url","window","URL","createObjectURL","a","document","createElement","body","appendChild","style","download","href","click","workerScriptsPath","fileid","id","byZipper","undefined","updateAllEditorButtons","title","$","val","replace","letter","index","toUpperCase"],"mappings":"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"}