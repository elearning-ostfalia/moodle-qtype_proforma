{"version":3,"file":"taskdata.min.js","sources":["../../src/taskeditor/taskdata.js"],"sourcesContent":["// This file is part of ProFormA Question Type for Moodle\n//\n// ProFormA Question Type for Moodle is free software:\n// you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ProFormA Question Type for Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ProFormA Question Type for Moodle.\n// If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Helper functions for zipping and unzipping task\n *\n * @package    qtype\n * @subpackage proforma\n * @copyright  2023 Ostfalia Hochschule fuer angewandte Wissenschaften\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @author     // This file is part of ProFormA Question Type for Moodle\n //\n // ProFormA Question Type for Moodle is free software:\n // you can redistribute it and/or modify\n // it under the terms of the GNU General Public License as published by\n // the Free Software Foundation, either version 3 of the License, or\n // (at your option) any later version.\n //\n // ProFormA Question Type for Moodle is distributed in the hope that it will be useful,\n // but WITHOUT ANY WARRANTY; without even the implied warranty of\n // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n // GNU General Public License for more details.\n //\n // You should have received a copy of the GNU General Public License\n // along with ProFormA Question Type for Moodle.\n // If not, see <http://www.gnu.org/licenses/>.\n\n /**\n * Helper functions for reading and writen task\n *\n * @package    qtype\n * @subpackage proforma\n * @copyright  2023 Ostfalia Hochschule fuer angewandte Wissenschaften\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @author     eCULT-Team of Ostfalia University, K.Borm\n */\n\n\nimport {setErrorMessage, generateUUID} from \"./util\";\nimport * as taskeditorconfig from \"./config\";\nimport {FileStorage, fileStorages } from \"./file\";\n\nexport const T_LMS_USAGE = {\n    DISPLAY: 'display',\n    DOWNLOAD: 'download',\n    EDIT: 'edit'\n};\n\nexport const T_VISIBLE = {\n    YES: 'yes',\n    NO: 'no',\n    DELAYED: 'delayed'\n};\n\nexport const T_FILERESTRICTION_FORMAT = {\n    POSIX: 'posix-ere',\n    NONE: 'none'\n};\n\n\n\n// helper class\nclass XmlReader {\n    constructor(xmlText) {\n        this.xmlDoc = new DOMParser().parseFromString(xmlText,'text/xml');\n        if (!this.xmlDoc.evaluate) {\n            alert('XPATH not supported');\n            return;\n        }\n\n        /*\n        var parser = new DOMParser();\n        [\n            '<task xmlns=\"urn:proforma:v2.0\" lang=\"en\"/>',\n            '<task xmlns=\"urn:proforma:task:v1.0.1\" lang=\"en\" uuid=\"e7a50a36-e0b7-486f-be80-0f217e7bcb80\" xmlns:jartest=\"urn:proforma:tests:jartest:v1\" xmlns:praktomat=\"urn:proforma:praktomat:v0.2\" xmlns:unit=\"urn:proforma:tests:unittest:v1\"/>',\n            '<ns:root xmlns:ns=\"example.com/ns2\"/>'\n        ].forEach(function(item) {\n            var doc = parser.parseFromString(item, \"application/xml\");\n            alert('result of doc.lookupNamespaceURI(null): |' + doc.lookupNamespaceURI(null) + '|');\n        });\n\n*/\n        this.defaultns = this.xmlDoc.lookupNamespaceURI(null);\n        //alert('result of doc.lookupNamespaceURI(null): |' + doc.lookupNamespaceURI(null) + '|');\n\n        this.rootNode = this.xmlDoc;\n\n        const defaultns = this.defaultns;\n        this.nsResolver = function (prefix) {\n\n            switch (prefix) {\n                case 'dns': return defaultns; // 'urn:proforma:task:v1.0.1';\n                default:    return taskeditorconfig.resolveNamespace(prefix, defaultns);\n            }\n        };\n    }\n\n    setRootNode(node) {\n        this.rootNode = node;\n    }\n\n    readSingleNode(xpath, node) {\n        let contextNode = node?node:this.rootNode;\n        if (!contextNode) {\n            console.error('No node for ' + xpath);\n            return null;\n        }\n        const nodes = this.xmlDoc.evaluate(xpath, contextNode, this.nsResolver,\n            XPathResult.UNORDERED_NODE_ITERATOR_TYPE /*FIRST_ORDERED_NODE_TYPE*/, null);\n        return nodes.iterateNext(); // .singleNodeValue;\n    }\n\n    readSingleText(xpath, node, defaultValue) {\n        const nodes = this.xmlDoc.evaluate(xpath, node?node:this.rootNode, this.nsResolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null);\n        if (nodes.singleNodeValue)\n            return nodes.singleNodeValue.textContent.trim();\n        else {\n            if (typeof defaultValue !== 'undefined')\n                return defaultValue;\n            return null;\n        }\n    }\n\n    readNodes(xpath, node) {\n        return this.xmlDoc.evaluate(xpath, node?node:this.rootNode, this.nsResolver, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null);\n    }\n}\n\n\nclass XmlWriter {\n    constructor(xmlDoc, ns) {\n        this.xmlDoc = xmlDoc;\n        this.ns = ns;\n    }\n\n    createCDataElement(node, tag, value, ns = undefined) {\n        let newTag = this.xmlDoc.createElementNS(ns?ns:this.ns, tag);\n        newTag.appendChild(this.xmlDoc.createCDATASection(value));\n        node.appendChild(newTag);\n        return newTag;\n    }\n\n    createTextElement(node, tag, value, ns = undefined, cdata = false) {\n        let newTag = this.xmlDoc.createElementNS(ns?ns:this.ns, tag);\n        if (cdata) {\n            newTag.appendChild(this.xmlDoc.createCDATASection(value));\n            throw new SyntaxError('cdata not supported, use createCDataElement');\n        }\n        else\n            newTag.appendChild(this.xmlDoc.createTextNode(value));\n        node.appendChild(newTag);\n        return newTag;\n    }\n\n    createOptionalTextElement(node, tag, value, ns = undefined, cdata = false) {\n        if (cdata) {\n            throw new SyntaxError('cdata not supported, use createOptionalTextElement');\n        }\n        if (value === '')\n            return;\n        return this.createTextElement(node, tag, value, ns, cdata);\n    }\n\n    createOptionalCDataElement(node, tag, value, ns = undefined) {\n        if (value === '')\n            return;\n        return this.createCDataElement(node, tag, value, ns);\n    }\n}\n\n// task data structures\nexport class TaskFileRef {\n    constructor(id) {\n        this.refid = id;\n    }\n}\n\nexport class TaskFile {\n    constructor() {\n        this.filename = '';\n        this.usedByGrader = false;\n        this.usageInLms = null;\n        this.visible = T_VISIBLE.NO;\n        this.id = null;\n        this.filetype = null;\n        this.comment = null;\n        this.content = null;\n        this.binary = null;\n    }\n}\n\nexport class TaskFileRestriction {\n    constructor(filename, required, format) {\n        this.restriction = filename;\n        this.required = required;\n        this.format = format;\n    }\n}\n\n\nexport class TaskModelSolution {\n    constructor() {\n        this.id = null;\n        this.description = \"\";\n        this.comment = \"\";\n        this.filerefs = [];\n    }\n}\n\n\nexport class TaskTest {\n    constructor() {\n        this.id = null;\n        this.title = null;\n        this.description = \"\";\n        this.comment = \"\";\n        this.testtype = null;\n        this.filerefs = [];\n        this.writeCallback = null;\n        this.uiElement = null;\n    }\n}\n\nexport class TaskClass {\n\n    constructor() {\n        this.title = '';\n        this.description = '';\n        this.comment = '';\n        this.proglang = '';\n        this.proglangVersion = '';\n        this.parentuuid = null;\n        this.uuid = null;\n        this.lang = 'de';\n        this.sizeSubmission = 0;\n        this.filenameRegExpSubmission = '';\n        this.codeskeleton = '';\n\n        this.fileRestrictions = [];\n        this.files = [];\n        // this.external-resources ;\n        this.modelsolutions = [];\n        this.tests = [];\n        this.gradinghints = [];\n    }\n\n\n    findFilenameForId(id) {\n        let filename = undefined;\n        this.files.forEach(function(item) {\n            if (item.id === id) {\n                filename = item.filename;\n            }\n        });\n        return filename;\n    }\n\n    readTestConfig(xmlfile, testid, configItem, context) {\n        try {\n            let xmlReader = new XmlReader(xmlfile);\n            const textnode = xmlReader.readSingleNode('/dns:task/dns:tests/dns:test[@id=\"'+testid+'\"]');\n            if (!textnode) {\n                throw new Error('XML: Missing node for test \"' + testid + '\" under task/tests');\n            }\n            xmlReader.setRootNode(textnode);\n            let configNodeNode = xmlReader.readSingleNode(\"dns:test-configuration\");\n            if (!configNodeNode) {\n                throw new Error('XML: Missing node for test-configuration under test \"' + testid + '\"');\n            }\n            configItem.onReadXml(this.tests[testid], xmlReader, configNodeNode, context);\n        } catch (err){\n            console.error(err);\n            const text = \"Error while parsing test configuration in xml file:\\n\\n\" + err;\n            alert (text);\n            // setErrorMessage(\"Error while parsing test configuration in xml file\", err);\n        }\n    }\n\n    readXmlVersion101(xmlfile) {\n\n        let template_id = null;\n        let template_referenced = false; // is template referenced in test or somewhere else?\n\n\n        function readFileRefs(xmlReader, element, thisNode, visibility, task) {\n            let fileRefIterator = xmlReader.readNodes(\"dns:filerefs/dns:fileref\", thisNode);\n            let fileRefNode = fileRefIterator.iterateNext();\n            let counter = 0;\n            while (fileRefNode) {\n                let fileRef = new TaskFileRef();\n                fileRef.refid = xmlReader.readSingleText(\"@refid\", fileRefNode);\n                if (template_id && (template_id === fileRef.refid)) {\n                    template_referenced = true;\n                }\n                element.filerefs[counter++] = fileRef;\n                fileRefNode = fileRefIterator.iterateNext();\n                if (visibility != null) {\n                    // increase visibilty\n                    switch (task.files[fileRef.refid].visible) {\n                        case T_VISIBLE.NO:  task.files[fileRef.refid].visible = visibility; break;\n                        case T_VISIBLE.YES:  break;\n                        case T_VISIBLE.DELAYED:\n                            if (visibility === T_VISIBLE.YES)\n                                task.files[fileRef.refid].visible = visibility;\n                            break;\n                    }\n                }\n            }\n        }\n\n        try {\n            let xmlReader = new XmlReader(xmlfile);\n            xmlReader.setRootNode(xmlReader.readSingleNode(\"/dns:task\")); // => shorter xpaths\n\n            this.title = xmlReader.readSingleText(\"dns:meta-data/dns:title\");\n            this.description = xmlReader.readSingleText(\"dns:description\");\n            this.proglang = xmlReader.readSingleText(\"dns:proglang\");\n            this.proglangVersion = xmlReader.readSingleText(\"dns:proglang/@version\");\n            this.uuid = xmlReader.readSingleText(\"@uuid\");\n            this.lang = xmlReader.readSingleText(\"@lang\");\n            this.sizeSubmission = xmlReader.readSingleText(\"dns:submission-restrictions/dns:regexp-restriction/@max-size\");\n            if (this.sizeSubmission !== '')\n                this.sizeSubmission = this.sizeSubmission * 1000; // convert to bytes (or *1024?)\n            // mimetype is unsupported\n            // this.mimeTypeRegExpSubmission = xmlReader.readSingleText(\"dns:submission-restrictions/dns:regexp-restriction\");\n\n            // read files\n            let iterator = xmlReader.readNodes(\"dns:files/dns:file\");\n            let thisNode = iterator.iterateNext();\n\n            while (thisNode) {\n                let taskfile = new TaskFile();\n                taskfile.id = xmlReader.readSingleText(\"@id\", thisNode);\n                const fileclass = xmlReader.readSingleText(\"@class\", thisNode);\n                switch(fileclass) {\n                    case 'internal':\n                    case 'internal-library':\n                        taskfile.usedByGrader = true;\n                        taskfile.usageInLms = null;\n                        taskfile.visible = T_VISIBLE.NO;\n                        break;\n                    case 'template':\n                        if (this.codeskeleton === '') {\n                            template_id = taskfile.id;\n                            this.codeskeleton = thisNode.textContent;\n                            taskfile.usedByGrader = false;\n                            taskfile.usageInLms = T_LMS_USAGE.EDIT;\n                            taskfile.visible = T_VISIBLE.YES;\n                        }\n                        else {\n                            taskfile.usedByGrader = false;\n                            //taskfile.usageInLms = T_LMS_USAGE.EDIT;\n                            taskfile.usageInLms = T_LMS_USAGE.DOWNLOAD;\n                            taskfile.visible = T_VISIBLE.YES;\n                        }\n                        break;\n                    case 'instruction':\n                        taskfile.usedByGrader = false;\n                        taskfile.usageInLms = T_LMS_USAGE.DOWNLOAD;\n                        taskfile.visible = T_VISIBLE.YES;\n                        break;\n                    case 'library':\n                        taskfile.usedByGrader = true;\n                        taskfile.usageInLms = T_LMS_USAGE.DOWNLOAD;\n                        taskfile.visible = T_VISIBLE.YES;\n                        break;\n                }\n                taskfile.comment = xmlReader.readSingleText(\"@comment\", thisNode);\n                taskfile.filetype = xmlReader.readSingleText(\"@type\", thisNode);\n                taskfile.filename = xmlReader.readSingleText(\"@filename\", thisNode);\n                taskfile.content = thisNode.textContent;\n                this.files[taskfile.id] = taskfile;\n                thisNode = iterator.iterateNext();\n            }\n\n            // read model solutions(s)\n            iterator = xmlReader.readNodes(\"dns:model-solutions/dns:model-solution\");\n            thisNode = iterator.iterateNext();\n            while (thisNode) {\n                let modelSolution = new TaskModelSolution();\n                modelSolution.id = xmlReader.readSingleText(\"@id\", thisNode);\n                modelSolution.comment = xmlReader.readSingleText(\"@comment\", thisNode);\n                readFileRefs(xmlReader, modelSolution, thisNode, T_VISIBLE.DELAYED, this);\n                this.modelsolutions[modelSolution.id] = modelSolution;\n                thisNode = iterator.iterateNext();\n            }\n\n            // read test(s)\n            iterator = xmlReader.readNodes(\"dns:tests/dns:test\");\n            thisNode = iterator.iterateNext();\n            let counter = 0;\n            while (thisNode) {\n                let test = new TaskTest();\n                test.id = xmlReader.readSingleText(\"@id\", thisNode);\n                test.title = xmlReader.readSingleText(\"dns:title\", thisNode);\n                test.testtype = xmlReader.readSingleText(\"dns:test-type\", thisNode);\n\n                let configIterator = xmlReader.readNodes(\"dns:test-configuration\", thisNode);\n                let configNode = configIterator.iterateNext();\n                readFileRefs(xmlReader, test, configNode);\n\n                this.tests[counter] = test;\n                counter++;\n                thisNode = iterator.iterateNext();\n            }\n\n            // check if template is referenced somewhere. If not then the file can be deleted!\n            if (!template_referenced) {\n                delete this.files[template_id];\n            }\n\n        } catch (err){\n            //alert (err);\n            setErrorMessage(\"Error while parsing the xml file. The file has not been imported.\", err);\n        }\n    }\n\n\n    readXmlVersion2(xmlfile) {\n\n        function readFileRefs(xmlReader, element, thisNode) {\n            let fileRefIterator = xmlReader.readNodes(\"dns:filerefs/dns:fileref\", thisNode);\n            let fileRefNode = fileRefIterator.iterateNext();\n            let counter = 0;\n            while (fileRefNode) {\n                let fileRef = new TaskFileRef();\n                fileRef.refid = xmlReader.readSingleText(\"@refid\", fileRefNode);\n                element.filerefs[counter++] = fileRef;\n                fileRefNode = fileRefIterator.iterateNext();\n            }\n        }\n\n        try {\n            let xmlReader = new XmlReader(xmlfile);\n            xmlReader.setRootNode(xmlReader.readSingleNode(\"/dns:task\")); // => shorter xpaths\n\n            this.title = xmlReader.readSingleText(\"dns:title\");\n            this.description = xmlReader.readSingleText(\"dns:description\");\n            this.comment = xmlReader.readSingleText(\"dns:internal-description\");\n            this.proglang = xmlReader.readSingleText(\"dns:proglang\");\n            this.proglangVersion = xmlReader.readSingleText(\"dns:proglang/@version\");\n            this.uuid = xmlReader.readSingleText(\"@uuid\");\n            this.lang = xmlReader.readSingleText(\"@lang\");\n            this.sizeSubmission = xmlReader.readSingleText(\"dns:submission-restrictions/@max-size\");\n\n            let iterator = xmlReader.readNodes(\"dns:submission-restrictions/dns:file-restriction\");\n            let thisNode = iterator.iterateNext();\n            let editCounter = 0;\n            while (thisNode) {\n                const required =\n                this.fileRestrictions[editCounter++] = new TaskFileRestriction(thisNode.textContent,\n                    xmlReader.readSingleText(\"@required\", thisNode, \"true\")==='true',\n                    xmlReader.readSingleText(\"@pattern-format\", thisNode));\n                thisNode = iterator.iterateNext();\n            }\n\n            // read files\n            iterator = xmlReader.readNodes(\"dns:files/dns:file\");\n            thisNode = iterator.iterateNext();\n            editCounter = 0;\n            while (thisNode) {\n                let taskfile = new TaskFile();\n                taskfile.id = xmlReader.readSingleText(\"@id\", thisNode);\n                //taskfile.fileclass = xmlReader.readSingleText(\"@class\", thisNode);\n                taskfile.usedByGrader = (xmlReader.readSingleText(\"@used-by-grader\", thisNode)==='yes');\n                taskfile.usageInLms = xmlReader.readSingleText(\"@usage-by-lms\", thisNode);\n                taskfile.visible = xmlReader.readSingleText(\"@visible\", thisNode);\n                // todo:\n                taskfile.comment = xmlReader.readSingleText(\"dns:internal-description\", thisNode);\n                let content = xmlReader.readSingleNode('*', thisNode); // nodeValue\n                if (content) {\n                    switch (content.nodeName) {\n                        case \"embedded-txt-file\":\n                            taskfile.filetype = 'embedded';\n                            taskfile.filename = xmlReader.readSingleText(\"@filename\", content);\n                            taskfile.content = content.textContent;\n                            taskfile.binary = false;\n                            break;\n                        case \"embedded-bin-file\":\n                            // taskfile.filetype = 'embedded';\n                            function b64DecodeUnicode(encoded) {\n                                return Uint8Array.from(atob(encoded), c => c.charCodeAt(0));\n                            }\n                            taskfile.filetype = 'file';\n                            taskfile.filename = xmlReader.readSingleText(\"@filename\", content);\n                            const filecontent =  b64DecodeUnicode(content.textContent);\n                            taskfile.content = filecontent;\n                            taskfile.binary = true;\n                            console.log(taskfile.id + ' is embedded-bin-file');\n                            // console.log(filecontent);\n                            console.log(filecontent.length);\n                            const mimetype = taskeditorconfig.getMimeType('', taskfile.filename); //get mime type\n                            let fileObject = new FileStorage(true, mimetype, filecontent, taskfile.filename);\n                            fileObject.setSize(filecontent.length);\n                            fileStorages[taskfile.id] = fileObject;\n                            break;\n                        case \"attached-bin-file\":\n                            taskfile.filetype = 'file';\n                            taskfile.filename = content.textContent;\n                            taskfile.binary = true;\n                            break;\n                        default:\n                            setErrorMessage(\"Unknown file type for file #\". taskfile.id);\n                    }\n                } else {\n                    setErrorMessage(\"No file content for file #\". taskfile.id);\n                }\n\n                // post processing:\n                // copy file content for editor in associated text area\n                const displaymode = xmlReader.readSingleText(\"@usage-by-lms\", thisNode);\n                if (taskfile.usageInLms === T_LMS_USAGE.EDIT) {\n                    if (editCounter === 0) {\n                        // do not store as file\n                        this.codeskeleton = taskfile.content;\n                    } else {\n                        this.files[taskfile.id] = taskfile;\n                    }\n                    editCounter++;\n                } else {\n                    this.files[taskfile.id] = taskfile;\n                }\n\n\n/*\n                let embeddedTextFile = xmlReader.readSingleNode(\"embedded-txt-file\");\n                if (embeddedTextFile) {\n                    taskfile.filetype = 'embedded';\n                    taskfile.filename = xmlReader.readSingleText(\"@filename\", embeddedTextFile);\n                    taskfile.content = embeddedTextFile.textContent;\n                } else {\n                    let attachedBinFile = xmlReader.readSingleNode(\"attached-bin-file\");\n                    if (attachedBinFile) {\n                        taskfile.filetype = 'file';\n                        taskfile.filename = xmlReader.readSingleText(\"@filename\", attachedBinFile);\n                    } else {\n                        setErrorMessage(\"Unknown file type for file #\". taskfile.id);\n                    }\n                }\n*/\n\n\n\n                thisNode = iterator.iterateNext();\n            }\n\n            // read model solutions(s)\n            iterator = xmlReader.readNodes(\"dns:model-solutions/dns:model-solution\");\n            thisNode = iterator.iterateNext();\n            while (thisNode) {\n                let modelSolution = new TaskModelSolution();\n                modelSolution.id = xmlReader.readSingleText(\"@id\", thisNode);\n                modelSolution.description = xmlReader.readSingleText(\"dns:description\", thisNode);\n                modelSolution.comment = xmlReader.readSingleText(\"dns:internal-description\", thisNode);\n                readFileRefs(xmlReader, modelSolution, thisNode);\n                this.modelsolutions[modelSolution.id] = modelSolution;\n                thisNode = iterator.iterateNext();\n            }\n\n            // read test(s)\n            iterator = xmlReader.readNodes(\"dns:tests/dns:test\");\n            thisNode = iterator.iterateNext();\n            let counter = 0;\n            while (thisNode) {\n                let test = new TaskTest();\n                test.id = xmlReader.readSingleText(\"@id\", thisNode);\n                test.title = xmlReader.readSingleText(\"dns:title\", thisNode);\n                test.description = xmlReader.readSingleText(\"dns:description\", thisNode);\n                test.comment = xmlReader.readSingleText(\"dns:internal-description\", thisNode);\n                test.testtype = xmlReader.readSingleText(\"dns:test-type\", thisNode);\n\n                let configIterator = xmlReader.readNodes(\"dns:test-configuration\", thisNode);\n                let configNode = configIterator.iterateNext();\n                readFileRefs(xmlReader, test, configNode);\n\n                this.tests[counter] = test;\n                counter++;\n                thisNode = iterator.iterateNext();\n            }\n\n            // read grading hints\n            const gradingfunction = xmlReader.readSingleText(\"dns:grading-hints/dns:root/@function\");\n            if (gradingfunction && gradingfunction !== 'sum') {\n                setErrorMessage(\"Grading hints function \" + gradingfunction + \" is not supported\");\n            }\n            iterator = xmlReader.readNodes(\"dns:grading-hints/dns:root/dns:test-ref\");\n            thisNode = iterator.iterateNext();\n            while (thisNode) {\n                const id = xmlReader.readSingleText(\"@ref\", thisNode);\n                this.tests.forEach(function(test) {\n                    if (test.id === id)\n                        test.weight = xmlReader.readSingleText(\"@weight\", thisNode);\n                });\n                thisNode = iterator.iterateNext();\n            }\n\n       } catch (err){\n           //alert (err);\n           setErrorMessage(\"Error while parsing the xml file. The file has not been imported.\", err);\n       }\n    }\n\n    readXml(xmlfile) {\n        let xmlReader = new XmlReader(xmlfile);\n        switch (xmlReader.defaultns) {\n            case 'urn:proforma:task:v1.0.1': return this.readXmlVersion101(xmlfile);\n            case 'urn:proforma:v2.0': return this.readXmlVersion2(xmlfile);\n            default:\n                setErrorMessage(\"Unsupported ProFormA version \" + xmlReader.defaultns);\n        }\n    }\n\n\n    // todo: read data directly from user input instead of using TaskClass object\n    writeXml(topLevelDoc, rootNode) {\n        console.log('*** TaskClass.writeXml');\n\n        let xmlDoc = null;\n        let files = null;\n        let fileRestrictions = null;\n        let modelsolutions = null;\n        let tests = null;\n        let gradingRoot = null;\n        let xmlWriter = null;\n        const xmlns = \"urn:proforma:v2.0\";\n        let task = null;\n\n        /* Version 1.0.1\n        function writeFile(item, index) {\n            let fileElem = xmlDoc.createElementNS(xmlns, \"file\");\n            fileElem.setAttribute(\"class\", item.fileclass);\n            fileElem.setAttribute(\"comment\", item.comment);\n            fileElem.setAttribute(\"filename\", item.filename);\n            fileElem.setAttribute(\"id\", item.id);\n            fileElem.setAttribute(\"type\", item.filetype);\n            files.appendChild(fileElem);\n            if (item.filetype === 'embedded')\n                fileElem.appendChild(xmlDoc.createCDATASection(item.content));\n        }\n        */\n\n        // version 2.0\n\n        function writeCodeSkeleton(task, id) {\n            if (task.codeskeleton) {\n                let fileElem = xmlDoc.createElementNS(xmlns, \"file\");\n                fileElem.setAttribute(\"id\", id);\n                fileElem.setAttribute(\"used-by-grader\", 'false');\n                fileElem.setAttribute(\"usage-by-lms\", T_LMS_USAGE.EDIT);\n                fileElem.setAttribute(\"visible\", T_VISIBLE.YES);\n\n                // fileElem.setAttribute(\"comment\", item.comment);\n                files.appendChild(fileElem);\n                let fileContentElem = xmlDoc.createElementNS(xmlns, \"embedded-txt-file\");\n                fileContentElem.setAttribute(\"filename\", 'code.txt');\n                fileContentElem.appendChild(xmlDoc.createCDATASection(task.codeskeleton));\n                fileElem.appendChild(fileContentElem);\n                xmlWriter.createOptionalTextElement(fileElem, 'internal-description', 'Code Skeleton for Editor');\n            }\n        }\n\n        function writeFile(item, index) {\n            let fileElem = xmlDoc.createElementNS(xmlns, \"file\");\n            fileElem.setAttribute(\"id\", item.id);\n            //fileElem.setAttribute(\"class\", item.fileclass);\n            fileElem.setAttribute(\"used-by-grader\", item.usedByGrader);\n            if (item.usageInLms) // optional\n                fileElem.setAttribute(\"usage-by-lms\", item.usageInLms);\n            fileElem.setAttribute(\"visible\", item.visible);\n\n            // fileElem.setAttribute(\"comment\", item.comment);\n            files.appendChild(fileElem);\n            if (item.filetype === 'embedded') {\n                let fileContentElem = xmlDoc.createElementNS(xmlns, \"embedded-txt-file\");\n                fileContentElem.setAttribute(\"filename\", item.filename);\n                fileContentElem.appendChild(xmlDoc.createCDATASection(item.content));\n                fileElem.appendChild(fileContentElem);\n            } else {\n                xmlWriter.createTextElement(fileElem, 'attached-bin-file', item.filename);\n            }\n            xmlWriter.createOptionalTextElement(fileElem, 'internal-description', item.comment);\n        }\n\n        function writeModelSolution(item, index) {\n            function writeFileref(file, index) {\n                if (file.refid) {\n                    let fileref = xmlDoc.createElementNS(xmlns, \"fileref\");\n                    fileref.setAttribute(\"refid\", file.refid);\n                    filerefs.appendChild(fileref);\n                }\n            }\n            let msElem = xmlDoc.createElementNS(xmlns, \"model-solution\");\n            // msElem.setAttribute(\"description\", item.comment); // alt\n            msElem.setAttribute(\"id\", item.id);\n            modelsolutions.appendChild(msElem);\n            let filerefs = xmlDoc.createElementNS(xmlns, \"filerefs\");\n            msElem.appendChild(filerefs);\n            item.filerefs.forEach(writeFileref);\n            // remove filerefs is no fileref available\n            let childs = filerefs.getElementsByTagName('fileref');\n            if (childs.length === 0) {\n                msElem.removeChild(filerefs);\n            }\n            xmlWriter.createOptionalTextElement(msElem, 'description', item.description);\n            xmlWriter.createOptionalTextElement(msElem, 'internal-description', item.comment);\n        }\n\n        function writeTest(item, index) {\n            console.log('*** TaskClass.writeTest');\n            console.log(item);\n            function writeFileref(file, index) {\n                if (file.refid) {\n                    let fileref = xmlDoc.createElementNS(xmlns, \"fileref\");\n                    fileref.setAttribute(\"refid\", file.refid);\n                    filerefs.appendChild(fileref);\n                }\n            }\n            //console.log('writeXml: create ' + item.title);\n\n            let testElem = xmlDoc.createElementNS(xmlns, \"test\");\n            testElem.setAttribute(\"id\", item.id);\n            xmlWriter.createTextElement(testElem, 'title', item.title);\n            xmlWriter.createOptionalTextElement(testElem, 'description', item.description);\n            xmlWriter.createOptionalTextElement(testElem, 'internal-description', item.comment);\n            xmlWriter.createTextElement(testElem, 'test-type', item.testtype);\n            let config = xmlDoc.createElementNS(xmlns, \"test-configuration\");\n            testElem.appendChild(config);\n            let filerefs = xmlDoc.createElementNS(xmlns, \"filerefs\");\n            config.appendChild(filerefs);\n            item.filerefs.forEach(writeFileref);\n            // remove filerefs is no fileref available\n            let childs = filerefs.getElementsByTagName('fileref');\n            if (childs.length === 0) {\n                config.removeChild(filerefs);\n            }\n\n            tests.appendChild(testElem);\n            if (item.configItem) {\n                console.log('*** item.configItem.onWriteXml');\n\n                // alert('config write xml');\n                item.configItem.onWriteXml(item, config, xmlDoc, xmlWriter, task);\n            }\n        }\n\n        function writeGradingTest(item, index) {\n            let testElem = xmlDoc.createElementNS(xmlns, \"test-ref\");\n            testElem.setAttribute(\"weight\", item.weight);\n            testElem.setAttribute(\"ref\", item.id);\n            gradingRoot.appendChild(testElem);\n        }\n\n        function writeFileRestriction(item, index) {\n            //let regexp = xmlWriter.createTextElement(submission, \"regexp-restriction\", this.filenameRegExpSubmission);\n            //submission.appendChild(regexp);\n            // regexp.setAttribute(\"mime-type-regexp\", this.mimeTypeRegExpSubmission);\n\n\n            let fileElem = //xmlDoc.createElementNS(xmlns, \"file-restriction\");\n            xmlWriter.createOptionalTextElement(fileRestrictions, 'file-restriction', item.restriction, xmlns);\n            if (!item.required) // optional, defaults to true\n                fileElem.setAttribute(\"required\", item.required);\n\n            if (item.format) // optional, defaults to none\n                fileElem.setAttribute(\"pattern-format\", item.format);\n\n            //fileRestrictions.appendChild(fileElem);\n        }\n\n\n        try {\n\n            if (topLevelDoc) {\n                xmlDoc = topLevelDoc;\n                task = xmlDoc.createElementNS(xmlns, \"task\");\n                rootNode.appendChild(task);\n            }\n            else {\n                xmlDoc = document.implementation.createDocument(xmlns, \"task\", null);\n                task = xmlDoc.documentElement;\n            }\n\n            task.setAttribute(\"lang\", this.lang);\n            task.setAttribute(\"uuid\", this.uuid);\n            // task.setAttribute(\"uuid\", generateUUID());// this.uuid);\n            //taskeditorconfig.writeNamespaces(task);\n\n            xmlWriter = new XmlWriter(xmlDoc, xmlns);\n\n            xmlWriter.createTextElement(task, 'title', this.title);\n            xmlWriter.createCDataElement(task, 'description', this.description);\n            xmlWriter.createOptionalCDataElement(task, 'internal-description', this.comment);\n            let proglang = xmlWriter.createTextElement(task, 'proglang', this.proglang);\n            proglang.setAttribute(\"version\", this.proglangVersion);\n\n            fileRestrictions = xmlDoc.createElementNS(xmlns, \"submission-restrictions\");\n            if (this.sizeSubmission)\n                fileRestrictions.setAttribute(\"max-size\", this.sizeSubmission);\n            task.appendChild(fileRestrictions);\n            this.fileRestrictions.forEach(writeFileRestriction);\n\n            files = xmlDoc.createElementNS(xmlns, \"files\");\n            task.appendChild(files);\n            writeCodeSkeleton(this, 'codeskeleton');\n            this.files.forEach(writeFile);\n\n            modelsolutions = xmlDoc.createElementNS(xmlns, \"model-solutions\");\n            task.appendChild(modelsolutions);\n            this.modelsolutions.forEach(writeModelSolution);\n\n            tests = xmlDoc.createElementNS(xmlns, \"tests\");\n            task.appendChild(tests);\n            const length = this.tests.length;\n            this.tests.forEach(writeTest);\n\n            // grading-hints\n            let gradinghints = xmlDoc.createElementNS(xmlns, \"grading-hints\");\n            task.appendChild(gradinghints);\n            gradingRoot = xmlDoc.createElementNS(xmlns, \"root\");\n            gradingRoot.setAttribute(\"function\", \"sum\");\n            gradinghints.appendChild(gradingRoot);\n            this.tests.forEach(writeGradingTest);\n\n            let metadata = xmlDoc.createElementNS(xmlns, \"meta-data\");\n            task.appendChild(metadata);\n///            taskeditorconfig.writeXmlExtra(metadata, xmlDoc, xmlWriter);\n            //xmlWriter.createTextElement(metadata, 'praktomat:allowed-upload-filename-mimetypes', '(text/.*)');\n\n            let serializer = new XMLSerializer();\n            let result = serializer.serializeToString (xmlDoc);\n\n            if ((result.substring(0, 5) !== \"<?xml\")){\n                result = '<?xml version=\"1.0\"?>' + result;\n                // result = \"<?xml version='1.0' encoding='UTF-8'?>\" + result;\n            }\n\n            let xsds = [ 'xsd/proforma.xsd' ];\n            // do not add all xsds from configuration because not all of them may be used\n            // resulting in an error message\n            xsds = xsds.concat(taskeditorconfig.xsds);\n\n/*\n            if (!topLevelDoc) { // do not validate for XML part\n                // validate output\n                xsds.forEach(function (xsd_file, index) {\n                    $.get(xsd_file, function (data, textStatus, jqXHR) {      // read XSD schema\n                        const valid = xmllint.validateXML({xml: result, schema: jqXHR.responseText});\n                        if (valid.errors !== null) {                                // does not conform to schema\n                            //alert(xsd_file);\n                            setErrorMessage(\"Errors in XSD-Validation \" + xsd_file + \":\");\n                            valid.errors.some(function (error, index) {\n                                setErrorMessage(error);\n                                return index > 15;\n                            })\n                        }\n                    }).fail(function (jqXHR, textStatus, errorThrown) {\n                        setErrorMessage(\"XSD-Schema \" + xsd_file + \" not found.\", errorThrown);\n                    });\n                });\n            }\n*/\n            return result;\n        } catch (err){\n            setErrorMessage(\"Error creating task xml file.\", err);\n            return '';\n        }\n    }\n}"],"names":["T_LMS_USAGE","DISPLAY","DOWNLOAD","EDIT","T_VISIBLE","YES","NO","DELAYED","POSIX","NONE","XmlReader","constructor","xmlText","xmlDoc","DOMParser","parseFromString","this","evaluate","alert","defaultns","lookupNamespaceURI","rootNode","nsResolver","prefix","taskeditorconfig","resolveNamespace","setRootNode","node","readSingleNode","xpath","contextNode","console","error","XPathResult","UNORDERED_NODE_ITERATOR_TYPE","iterateNext","readSingleText","defaultValue","nodes","FIRST_ORDERED_NODE_TYPE","singleNodeValue","textContent","trim","readNodes","XmlWriter","ns","createCDataElement","tag","value","undefined","newTag","createElementNS","appendChild","createCDATASection","createTextElement","cdata","SyntaxError","createTextNode","createOptionalTextElement","createOptionalCDataElement","TaskFileRef","id","refid","TaskFile","filename","usedByGrader","usageInLms","visible","filetype","comment","content","binary","TaskFileRestriction","required","format","restriction","TaskModelSolution","description","filerefs","TaskTest","title","testtype","writeCallback","uiElement","proglang","proglangVersion","parentuuid","uuid","lang","sizeSubmission","filenameRegExpSubmission","codeskeleton","fileRestrictions","files","modelsolutions","tests","gradinghints","findFilenameForId","forEach","item","readTestConfig","xmlfile","testid","configItem","context","xmlReader","textnode","Error","configNodeNode","onReadXml","err","readXmlVersion101","template_id","template_referenced","readFileRefs","element","thisNode","visibility","task","fileRefIterator","fileRefNode","counter","fileRef","iterator","taskfile","modelSolution","test","configIterator","readXmlVersion2","editCounter","nodeName","filecontent","encoded","Uint8Array","from","atob","c","charCodeAt","log","length","mimetype","getMimeType","fileObject","FileStorage","setSize","configNode","gradingfunction","weight","readXml","writeXml","topLevelDoc","gradingRoot","xmlWriter","xmlns","document","implementation","createDocument","documentElement","setAttribute","index","fileElem","fileContentElem","writeCodeSkeleton","msElem","file","fileref","getElementsByTagName","removeChild","testElem","config","onWriteXml","metadata","result","XMLSerializer","serializeToString","substring","xsds","concat"],"mappings":"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"}