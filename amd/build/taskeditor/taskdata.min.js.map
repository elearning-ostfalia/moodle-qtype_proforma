{"version":3,"file":"taskdata.min.js","sources":["../../src/taskeditor/taskdata.js"],"sourcesContent":["// This file is part of ProFormA Question Type for Moodle\n//\n// ProFormA Question Type for Moodle is free software:\n// you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ProFormA Question Type for Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ProFormA Question Type for Moodle.\n// If not, see <http://www.gnu.org/licenses/>.\n\n /**\n * Helper functions for reading and writen task\n *\n * @package    qtype\n * @subpackage proforma\n * @copyright  2023 Ostfalia Hochschule fuer angewandte Wissenschaften\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @author     eCULT-Team of Ostfalia University, K.Borm\n */\n\n\nimport {setErrorMessage, generateUUID} from \"./helper\";\nimport * as taskeditorconfig from \"./config\";\nimport {FileStorage, fileStorages } from \"./file\";\n\nexport const T_LMS_USAGE = {\n    DISPLAY: 'display',\n    DOWNLOAD: 'download',\n    EDIT: 'edit'\n};\n\nexport const T_VISIBLE = {\n    YES: 'yes',\n    NO: 'no',\n    DELAYED: 'delayed'\n};\n\nexport const T_FILERESTRICTION_FORMAT = {\n    POSIX: 'posix-ere',\n    NONE: 'none'\n};\n\n\n\n// helper class\nclass XmlReader {\n    constructor(xmlText) {\n        this.xmlDoc = new DOMParser().parseFromString(xmlText,'text/xml');\n        if (!this.xmlDoc.evaluate) {\n            alert('XPATH not supported');\n            return;\n        }\n\n        /*\n        var parser = new DOMParser();\n        [\n            '<task xmlns=\"urn:proforma:v2.0\" lang=\"en\"/>',\n            '<task xmlns=\"urn:proforma:task:v1.0.1\" lang=\"en\" uuid=\"e7a50a36-e0b7-486f-be80-0f217e7bcb80\" xmlns:jartest=\"urn:proforma:tests:jartest:v1\" xmlns:praktomat=\"urn:proforma:praktomat:v0.2\" xmlns:unit=\"urn:proforma:tests:unittest:v1\"/>',\n            '<ns:root xmlns:ns=\"example.com/ns2\"/>'\n        ].forEach(function(item) {\n            var doc = parser.parseFromString(item, \"application/xml\");\n            alert('result of doc.lookupNamespaceURI(null): |' + doc.lookupNamespaceURI(null) + '|');\n        });\n\n*/\n        this.defaultns = this.xmlDoc.lookupNamespaceURI(null);\n        //alert('result of doc.lookupNamespaceURI(null): |' + doc.lookupNamespaceURI(null) + '|');\n\n        this.rootNode = this.xmlDoc;\n\n        const defaultns = this.defaultns;\n        this.nsResolver = function (prefix) {\n\n            switch (prefix) {\n                case 'dns': return defaultns; // 'urn:proforma:task:v1.0.1';\n                default:    return taskeditorconfig.resolveNamespace(prefix, defaultns);\n            }\n        };\n    }\n\n    setRootNode(node) {\n        this.rootNode = node;\n    }\n\n    readSingleNode(xpath, node) {\n        let contextNode = node?node:this.rootNode;\n        if (!contextNode) {\n            console.error('No node for ' + xpath);\n            return null;\n        }\n        const nodes = this.xmlDoc.evaluate(xpath, contextNode, this.nsResolver,\n            XPathResult.UNORDERED_NODE_ITERATOR_TYPE /*FIRST_ORDERED_NODE_TYPE*/, null);\n        return nodes.iterateNext(); // .singleNodeValue;\n    }\n\n    readSingleText(xpath, node, defaultValue) {\n        const nodes = this.xmlDoc.evaluate(xpath, node?node:this.rootNode, this.nsResolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null);\n        if (nodes.singleNodeValue)\n            return nodes.singleNodeValue.textContent.trim();\n        else {\n            if (typeof defaultValue !== 'undefined')\n                return defaultValue;\n            return null;\n        }\n    }\n\n    readNodes(xpath, node) {\n        return this.xmlDoc.evaluate(xpath, node?node:this.rootNode, this.nsResolver, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null);\n    }\n}\n\n\nclass XmlWriter {\n    constructor(xmlDoc, ns) {\n        this.xmlDoc = xmlDoc;\n        this.ns = ns;\n    }\n\n    createCDataElement(node, tag, value, ns = undefined) {\n        let newTag = this.xmlDoc.createElementNS(ns?ns:this.ns, tag);\n        newTag.appendChild(this.xmlDoc.createCDATASection(value));\n        node.appendChild(newTag);\n        return newTag;\n    }\n\n    createTextElement(node, tag, value, ns = undefined, cdata = false) {\n        let newTag = this.xmlDoc.createElementNS(ns?ns:this.ns, tag);\n        if (cdata) {\n            newTag.appendChild(this.xmlDoc.createCDATASection(value));\n            throw new SyntaxError('cdata not supported, use createCDataElement');\n        }\n        else\n            newTag.appendChild(this.xmlDoc.createTextNode(value));\n        node.appendChild(newTag);\n        return newTag;\n    }\n\n    createOptionalTextElement(node, tag, value, ns = undefined, cdata = false) {\n        if (cdata) {\n            throw new SyntaxError('cdata not supported, use createOptionalTextElement');\n        }\n        if (value === '')\n            return;\n        return this.createTextElement(node, tag, value, ns, cdata);\n    }\n\n    createOptionalCDataElement(node, tag, value, ns = undefined) {\n        if (value === '')\n            return;\n        return this.createCDataElement(node, tag, value, ns);\n    }\n}\n\n// task data structures\nexport class TaskFileRef {\n    constructor(id) {\n        this.refid = id;\n    }\n}\n\nexport class TaskFile {\n    constructor() {\n        this.filename = '';\n        this.usedByGrader = false;\n        this.usageInLms = null;\n        this.visible = T_VISIBLE.NO;\n        this.id = null;\n        this.filetype = null;\n        this.comment = null;\n        this.content = null;\n        this.binary = null;\n    }\n}\n\nexport class TaskFileRestriction {\n    constructor(filename, required, format) {\n        this.restriction = filename;\n        this.required = required;\n        this.format = format;\n    }\n}\n\n\nexport class TaskModelSolution {\n    constructor() {\n        this.id = null;\n        this.description = \"\";\n        this.comment = \"\";\n        this.filerefs = [];\n    }\n}\n\n\nexport class TaskTest {\n    constructor() {\n        this.id = null;\n        this.title = null;\n        this.description = \"\";\n        this.comment = \"\";\n        this.testtype = null;\n        this.filerefs = [];\n        this.writeCallback = null;\n        this.uiElement = null;\n        this.framework = null;\n    }\n}\n\nexport class TaskClass {\n\n    constructor() {\n        this.title = '';\n        this.description = '';\n        this.comment = '';\n        this.proglang = '';\n        this.proglangVersion = '';\n        this.parentuuid = null;\n        this.uuid = null;\n        this.lang = 'de';\n        this.sizeSubmission = 0;\n        this.filenameRegExpSubmission = '';\n        this.codeskeleton = '';\n\n        this.fileRestrictions = [];\n        this.files = [];\n        // this.external-resources ;\n        this.modelsolutions = [];\n        this.tests = [];\n        this.gradinghints = [];\n    }\n\n\n    findFilenameForId(id) {\n        let filename = undefined;\n        this.files.forEach(function(item) {\n            if (item.id === id) {\n                filename = item.filename;\n            }\n        });\n        return filename;\n    }\n\n    readTestConfig(xmlfile, testid, configItem, context) {\n        try {\n            let xmlReader = new XmlReader(xmlfile);\n            const textnode = xmlReader.readSingleNode('/dns:task/dns:tests/dns:test[@id=\"'+testid+'\"]');\n            if (!textnode) {\n                throw new Error('XML: Missing node for test \"' + testid + '\" under task/tests');\n            }\n            xmlReader.setRootNode(textnode);\n            let configNodeNode = xmlReader.readSingleNode(\"dns:test-configuration\");\n            if (!configNodeNode) {\n                throw new Error('XML: Missing node for test-configuration under test \"' + testid + '\"');\n            }\n            configItem.onReadXml(this.tests[testid], xmlReader, configNodeNode, context);\n        } catch (err){\n            console.error(err);\n            const text = \"Error while parsing test configuration in xml file:\\n\\n\" + err;\n            alert (text);\n            // setErrorMessage(\"Error while parsing test configuration in xml file\", err);\n        }\n    }\n\n    readXmlVersion101(xmlfile) {\n\n        let template_id = null;\n        let template_referenced = false; // is template referenced in test or somewhere else?\n\n\n        function readFileRefs(xmlReader, element, thisNode, visibility, task) {\n            let fileRefIterator = xmlReader.readNodes(\"dns:filerefs/dns:fileref\", thisNode);\n            let fileRefNode = fileRefIterator.iterateNext();\n            let counter = 0;\n            while (fileRefNode) {\n                let fileRef = new TaskFileRef();\n                fileRef.refid = xmlReader.readSingleText(\"@refid\", fileRefNode);\n                if (template_id && (template_id === fileRef.refid)) {\n                    template_referenced = true;\n                }\n                element.filerefs[counter++] = fileRef;\n                fileRefNode = fileRefIterator.iterateNext();\n                if (visibility != null) {\n                    // increase visibilty\n                    switch (task.files[fileRef.refid].visible) {\n                        case T_VISIBLE.NO:  task.files[fileRef.refid].visible = visibility; break;\n                        case T_VISIBLE.YES:  break;\n                        case T_VISIBLE.DELAYED:\n                            if (visibility === T_VISIBLE.YES)\n                                task.files[fileRef.refid].visible = visibility;\n                            break;\n                    }\n                }\n            }\n        }\n\n        try {\n            let xmlReader = new XmlReader(xmlfile);\n            xmlReader.setRootNode(xmlReader.readSingleNode(\"/dns:task\")); // => shorter xpaths\n\n            this.title = xmlReader.readSingleText(\"dns:meta-data/dns:title\");\n            this.description = xmlReader.readSingleText(\"dns:description\");\n            this.proglang = xmlReader.readSingleText(\"dns:proglang\");\n            this.proglangVersion = xmlReader.readSingleText(\"dns:proglang/@version\");\n            this.uuid = xmlReader.readSingleText(\"@uuid\");\n            this.lang = xmlReader.readSingleText(\"@lang\");\n            this.sizeSubmission = xmlReader.readSingleText(\"dns:submission-restrictions/dns:regexp-restriction/@max-size\");\n            if (this.sizeSubmission !== '')\n                this.sizeSubmission = this.sizeSubmission * 1000; // convert to bytes (or *1024?)\n            // mimetype is unsupported\n            // this.mimeTypeRegExpSubmission = xmlReader.readSingleText(\"dns:submission-restrictions/dns:regexp-restriction\");\n\n            // read files\n            let iterator = xmlReader.readNodes(\"dns:files/dns:file\");\n            let thisNode = iterator.iterateNext();\n\n            while (thisNode) {\n                let taskfile = new TaskFile();\n                taskfile.id = xmlReader.readSingleText(\"@id\", thisNode);\n                const fileclass = xmlReader.readSingleText(\"@class\", thisNode);\n                switch(fileclass) {\n                    case 'internal':\n                    case 'internal-library':\n                        taskfile.usedByGrader = true;\n                        taskfile.usageInLms = null;\n                        taskfile.visible = T_VISIBLE.NO;\n                        break;\n                    case 'template':\n                        if (this.codeskeleton === '') {\n                            template_id = taskfile.id;\n                            this.codeskeleton = thisNode.textContent;\n                            taskfile.usedByGrader = false;\n                            taskfile.usageInLms = T_LMS_USAGE.EDIT;\n                            taskfile.visible = T_VISIBLE.YES;\n                        }\n                        else {\n                            taskfile.usedByGrader = false;\n                            //taskfile.usageInLms = T_LMS_USAGE.EDIT;\n                            taskfile.usageInLms = T_LMS_USAGE.DOWNLOAD;\n                            taskfile.visible = T_VISIBLE.YES;\n                        }\n                        break;\n                    case 'instruction':\n                        taskfile.usedByGrader = false;\n                        taskfile.usageInLms = T_LMS_USAGE.DOWNLOAD;\n                        taskfile.visible = T_VISIBLE.YES;\n                        break;\n                    case 'library':\n                        taskfile.usedByGrader = true;\n                        taskfile.usageInLms = T_LMS_USAGE.DOWNLOAD;\n                        taskfile.visible = T_VISIBLE.YES;\n                        break;\n                }\n                taskfile.comment = xmlReader.readSingleText(\"@comment\", thisNode);\n                taskfile.filetype = xmlReader.readSingleText(\"@type\", thisNode);\n                taskfile.filename = xmlReader.readSingleText(\"@filename\", thisNode);\n                taskfile.content = thisNode.textContent;\n                this.files[taskfile.id] = taskfile;\n                thisNode = iterator.iterateNext();\n            }\n\n            // read model solutions(s)\n            iterator = xmlReader.readNodes(\"dns:model-solutions/dns:model-solution\");\n            thisNode = iterator.iterateNext();\n            while (thisNode) {\n                let modelSolution = new TaskModelSolution();\n                modelSolution.id = xmlReader.readSingleText(\"@id\", thisNode);\n                modelSolution.comment = xmlReader.readSingleText(\"@comment\", thisNode);\n                readFileRefs(xmlReader, modelSolution, thisNode, T_VISIBLE.DELAYED, this);\n                this.modelsolutions[modelSolution.id] = modelSolution;\n                thisNode = iterator.iterateNext();\n            }\n\n            // read test(s)\n            iterator = xmlReader.readNodes(\"dns:tests/dns:test\");\n            thisNode = iterator.iterateNext();\n            let counter = 0;\n            while (thisNode) {\n                let test = new TaskTest();\n                test.id = xmlReader.readSingleText(\"@id\", thisNode);\n                test.title = xmlReader.readSingleText(\"dns:title\", thisNode);\n                test.testtype = xmlReader.readSingleText(\"dns:test-type\", thisNode);\n\n                let configIterator = xmlReader.readNodes(\"dns:test-configuration\", thisNode);\n                let configNode = configIterator.iterateNext();\n                readFileRefs(xmlReader, test, configNode);\n\n                this.tests[counter] = test;\n                counter++;\n                thisNode = iterator.iterateNext();\n            }\n\n            // check if template is referenced somewhere. If not then the file can be deleted!\n            if (!template_referenced) {\n                delete this.files[template_id];\n            }\n\n        } catch (err){\n            //alert (err);\n            setErrorMessage(\"Error while parsing the xml file. The file has not been imported.\", err);\n        }\n    }\n\n\n    readXmlVersion2(xmlfile) {\n\n        function readFileRefs(xmlReader, element, thisNode) {\n            let fileRefIterator = xmlReader.readNodes(\"dns:filerefs/dns:fileref\", thisNode);\n            let fileRefNode = fileRefIterator.iterateNext();\n            let counter = 0;\n            while (fileRefNode) {\n                let fileRef = new TaskFileRef();\n                fileRef.refid = xmlReader.readSingleText(\"@refid\", fileRefNode);\n                element.filerefs[counter++] = fileRef;\n                fileRefNode = fileRefIterator.iterateNext();\n            }\n        }\n\n        try {\n            let xmlReader = new XmlReader(xmlfile);\n            xmlReader.setRootNode(xmlReader.readSingleNode(\"/dns:task\")); // => shorter xpaths\n\n            this.title = xmlReader.readSingleText(\"dns:title\");\n            this.description = xmlReader.readSingleText(\"dns:description\");\n            this.comment = xmlReader.readSingleText(\"dns:internal-description\");\n            this.proglang = xmlReader.readSingleText(\"dns:proglang\");\n            this.proglangVersion = xmlReader.readSingleText(\"dns:proglang/@version\");\n            this.uuid = xmlReader.readSingleText(\"@uuid\");\n            this.lang = xmlReader.readSingleText(\"@lang\");\n            this.sizeSubmission = xmlReader.readSingleText(\"dns:submission-restrictions/@max-size\");\n\n            let iterator = xmlReader.readNodes(\"dns:submission-restrictions/dns:file-restriction\");\n            let thisNode = iterator.iterateNext();\n            let editCounter = 0;\n            while (thisNode) {\n                const required =\n                this.fileRestrictions[editCounter++] = new TaskFileRestriction(thisNode.textContent,\n                    xmlReader.readSingleText(\"@required\", thisNode, \"true\")==='true',\n                    xmlReader.readSingleText(\"@pattern-format\", thisNode));\n                thisNode = iterator.iterateNext();\n            }\n\n            // read files\n            iterator = xmlReader.readNodes(\"dns:files/dns:file\");\n            thisNode = iterator.iterateNext();\n            editCounter = 0;\n            while (thisNode) {\n                let taskfile = new TaskFile();\n                taskfile.id = xmlReader.readSingleText(\"@id\", thisNode);\n                //taskfile.fileclass = xmlReader.readSingleText(\"@class\", thisNode);\n                taskfile.usedByGrader = (xmlReader.readSingleText(\"@used-by-grader\", thisNode)==='yes');\n                taskfile.usageInLms = xmlReader.readSingleText(\"@usage-by-lms\", thisNode);\n                taskfile.visible = xmlReader.readSingleText(\"@visible\", thisNode);\n                // todo:\n                taskfile.comment = xmlReader.readSingleText(\"dns:internal-description\", thisNode);\n                let content = xmlReader.readSingleNode('*', thisNode); // nodeValue\n                if (content) {\n                    switch (content.nodeName) {\n                        case \"embedded-txt-file\":\n                            taskfile.filetype = 'embedded';\n                            taskfile.filename = xmlReader.readSingleText(\"@filename\", content);\n                            taskfile.content = content.textContent;\n                            taskfile.binary = false;\n                            break;\n                        case \"embedded-bin-file\":\n                            // taskfile.filetype = 'embedded';\n                            function b64DecodeUnicode(encoded) {\n                                return Uint8Array.from(atob(encoded), c => c.charCodeAt(0));\n                            }\n                            taskfile.filetype = 'file';\n                            taskfile.filename = xmlReader.readSingleText(\"@filename\", content);\n                            const filecontent =  b64DecodeUnicode(content.textContent);\n                            taskfile.content = filecontent;\n                            taskfile.binary = true;\n                            // console.log(filecontent.length);\n                            const mimetype = taskeditorconfig.getMimeType('', taskfile.filename); //get mime type\n                            let fileObject = new FileStorage(true, mimetype, filecontent, taskfile.filename);\n                            fileObject.setSize(filecontent.length);\n                            fileStorages[taskfile.id] = fileObject;\n                            break;\n                        case \"attached-bin-file\":\n                            taskfile.filetype = 'file';\n                            taskfile.filename = content.textContent;\n                            taskfile.binary = true;\n                            break;\n                        default:\n                            setErrorMessage(\"Unknown file type for file #\". taskfile.id);\n                    }\n                } else {\n                    setErrorMessage(\"No file content for file #\". taskfile.id);\n                }\n\n                // post processing:\n                // copy file content for editor in associated text area\n                const displaymode = xmlReader.readSingleText(\"@usage-by-lms\", thisNode);\n                if (taskfile.usageInLms === T_LMS_USAGE.EDIT) {\n                    if (editCounter === 0) {\n                        // do not store as file\n                        this.codeskeleton = taskfile.content;\n                    } else {\n                        this.files[taskfile.id] = taskfile;\n                    }\n                    editCounter++;\n                } else {\n                    this.files[taskfile.id] = taskfile;\n                }\n\n\n/*\n                let embeddedTextFile = xmlReader.readSingleNode(\"embedded-txt-file\");\n                if (embeddedTextFile) {\n                    taskfile.filetype = 'embedded';\n                    taskfile.filename = xmlReader.readSingleText(\"@filename\", embeddedTextFile);\n                    taskfile.content = embeddedTextFile.textContent;\n                } else {\n                    let attachedBinFile = xmlReader.readSingleNode(\"attached-bin-file\");\n                    if (attachedBinFile) {\n                        taskfile.filetype = 'file';\n                        taskfile.filename = xmlReader.readSingleText(\"@filename\", attachedBinFile);\n                    } else {\n                        setErrorMessage(\"Unknown file type for file #\". taskfile.id);\n                    }\n                }\n*/\n\n\n\n                thisNode = iterator.iterateNext();\n            }\n\n            // read model solutions(s)\n            iterator = xmlReader.readNodes(\"dns:model-solutions/dns:model-solution\");\n            thisNode = iterator.iterateNext();\n            while (thisNode) {\n                let modelSolution = new TaskModelSolution();\n                modelSolution.id = xmlReader.readSingleText(\"@id\", thisNode);\n                modelSolution.description = xmlReader.readSingleText(\"dns:description\", thisNode);\n                modelSolution.comment = xmlReader.readSingleText(\"dns:internal-description\", thisNode);\n                readFileRefs(xmlReader, modelSolution, thisNode);\n                this.modelsolutions[modelSolution.id] = modelSolution;\n                thisNode = iterator.iterateNext();\n            }\n\n            // read test(s)\n            iterator = xmlReader.readNodes(\"dns:tests/dns:test\");\n            thisNode = iterator.iterateNext();\n            let counter = 0;\n            while (thisNode) {\n                let test = new TaskTest();\n                test.id = xmlReader.readSingleText(\"@id\", thisNode);\n                test.title = xmlReader.readSingleText(\"dns:title\", thisNode);\n                test.description = xmlReader.readSingleText(\"dns:description\", thisNode);\n                test.comment = xmlReader.readSingleText(\"dns:internal-description\", thisNode);\n                test.testtype = xmlReader.readSingleText(\"dns:test-type\", thisNode);\n                let configIterator = xmlReader.readNodes(\"dns:test-configuration\", thisNode);\n                let configNode = configIterator.iterateNext();\n                if (test.testtype.toLowerCase() === 'unittest') {\n                    // Check for optional framework\n                    let unitNode = xmlReader.readSingleNode(\"unit:unittest\", configNode);\n                    if (unitNode) {\n                        let framework = xmlReader.readSingleText(\"@framework\", unitNode);\n                        if (framework) {\n                            test.framework = framework;\n                        }\n                    }\n                }\n\n                readFileRefs(xmlReader, test, configNode);\n\n                this.tests[counter] = test;\n                counter++;\n                thisNode = iterator.iterateNext();\n            }\n\n            // read grading hints\n            const gradingfunction = xmlReader.readSingleText(\"dns:grading-hints/dns:root/@function\");\n            if (gradingfunction && gradingfunction !== 'sum') {\n                setErrorMessage(\"Grading hints function \" + gradingfunction + \" is not supported\");\n            }\n            iterator = xmlReader.readNodes(\"dns:grading-hints/dns:root/dns:test-ref\");\n            thisNode = iterator.iterateNext();\n            while (thisNode) {\n                const id = xmlReader.readSingleText(\"@ref\", thisNode);\n                this.tests.forEach(function(test) {\n                    if (test.id === id)\n                        test.weight = xmlReader.readSingleText(\"@weight\", thisNode);\n                });\n                thisNode = iterator.iterateNext();\n            }\n\n       } catch (err){\n           //alert (err);\n           setErrorMessage(\"Error while parsing the xml file. The file has not been imported.\", err);\n       }\n    }\n\n    readXml(xmlfile) {\n        let xmlReader = new XmlReader(xmlfile);\n        switch (xmlReader.defaultns) {\n            case 'urn:proforma:task:v1.0.1': return this.readXmlVersion101(xmlfile);\n            case 'urn:proforma:v2.0': return this.readXmlVersion2(xmlfile);\n            default:\n                setErrorMessage(\"Unsupported ProFormA version \" + xmlReader.defaultns);\n        }\n    }\n\n\n    // todo: read data directly from user input instead of using TaskClass object\n    writeXml(topLevelDoc, rootNode) {\n        console.log('*** TaskClass.writeXml');\n\n        let xmlDoc = null;\n        let files = null;\n        let fileRestrictions = null;\n        let modelsolutions = null;\n        let tests = null;\n        let gradingRoot = null;\n        let xmlWriter = null;\n        const xmlns = \"urn:proforma:v2.0\";\n        let task = null;\n\n        /* Version 1.0.1\n        function writeFile(item, index) {\n            let fileElem = xmlDoc.createElementNS(xmlns, \"file\");\n            fileElem.setAttribute(\"class\", item.fileclass);\n            fileElem.setAttribute(\"comment\", item.comment);\n            fileElem.setAttribute(\"filename\", item.filename);\n            fileElem.setAttribute(\"id\", item.id);\n            fileElem.setAttribute(\"type\", item.filetype);\n            files.appendChild(fileElem);\n            if (item.filetype === 'embedded')\n                fileElem.appendChild(xmlDoc.createCDATASection(item.content));\n        }\n        */\n\n        // version 2.0\n\n        function writeCodeSkeleton(task, id) {\n            if (task.codeskeleton) {\n                let fileElem = xmlDoc.createElementNS(xmlns, \"file\");\n                fileElem.setAttribute(\"id\", id);\n                fileElem.setAttribute(\"used-by-grader\", 'false');\n                fileElem.setAttribute(\"usage-by-lms\", T_LMS_USAGE.EDIT);\n                fileElem.setAttribute(\"visible\", T_VISIBLE.YES);\n\n                // fileElem.setAttribute(\"comment\", item.comment);\n                files.appendChild(fileElem);\n                let fileContentElem = xmlDoc.createElementNS(xmlns, \"embedded-txt-file\");\n                fileContentElem.setAttribute(\"filename\", 'code.txt');\n                fileContentElem.appendChild(xmlDoc.createCDATASection(task.codeskeleton));\n                fileElem.appendChild(fileContentElem);\n                xmlWriter.createOptionalTextElement(fileElem, 'internal-description', 'Code Skeleton for Editor');\n            }\n        }\n\n        function writeFile(item, index) {\n            let fileElem = xmlDoc.createElementNS(xmlns, \"file\");\n            fileElem.setAttribute(\"id\", item.id);\n            //fileElem.setAttribute(\"class\", item.fileclass);\n            fileElem.setAttribute(\"used-by-grader\", item.usedByGrader);\n            if (item.usageInLms) // optional\n                fileElem.setAttribute(\"usage-by-lms\", item.usageInLms);\n            fileElem.setAttribute(\"visible\", item.visible);\n\n            // fileElem.setAttribute(\"comment\", item.comment);\n            files.appendChild(fileElem);\n            if (item.filetype === 'embedded') {\n                let fileContentElem = xmlDoc.createElementNS(xmlns, \"embedded-txt-file\");\n                fileContentElem.setAttribute(\"filename\", item.filename);\n                fileContentElem.appendChild(xmlDoc.createCDATASection(item.content));\n                fileElem.appendChild(fileContentElem);\n            } else {\n                xmlWriter.createTextElement(fileElem, 'attached-bin-file', item.filename);\n            }\n            xmlWriter.createOptionalTextElement(fileElem, 'internal-description', item.comment);\n        }\n\n        function writeModelSolution(item, index) {\n            function writeFileref(file, index) {\n                if (file.refid) {\n                    let fileref = xmlDoc.createElementNS(xmlns, \"fileref\");\n                    fileref.setAttribute(\"refid\", file.refid);\n                    filerefs.appendChild(fileref);\n                }\n            }\n            let msElem = xmlDoc.createElementNS(xmlns, \"model-solution\");\n            // msElem.setAttribute(\"description\", item.comment); // alt\n            msElem.setAttribute(\"id\", item.id);\n            modelsolutions.appendChild(msElem);\n            let filerefs = xmlDoc.createElementNS(xmlns, \"filerefs\");\n            msElem.appendChild(filerefs);\n            item.filerefs.forEach(writeFileref);\n            // remove filerefs is no fileref available\n            let childs = filerefs.getElementsByTagName('fileref');\n            if (childs.length === 0) {\n                msElem.removeChild(filerefs);\n            }\n            xmlWriter.createOptionalTextElement(msElem, 'description', item.description);\n            xmlWriter.createOptionalTextElement(msElem, 'internal-description', item.comment);\n        }\n\n        function writeTest(item, index) {\n            console.log('*** TaskClass.writeTest');\n            console.log(item);\n            function writeFileref(file, index) {\n                if (file.refid) {\n                    let fileref = xmlDoc.createElementNS(xmlns, \"fileref\");\n                    fileref.setAttribute(\"refid\", file.refid);\n                    filerefs.appendChild(fileref);\n                }\n            }\n            //console.log('writeXml: create ' + item.title);\n\n            let testElem = xmlDoc.createElementNS(xmlns, \"test\");\n            testElem.setAttribute(\"id\", item.id);\n            xmlWriter.createTextElement(testElem, 'title', item.title);\n            xmlWriter.createOptionalTextElement(testElem, 'description', item.description);\n            xmlWriter.createOptionalTextElement(testElem, 'internal-description', item.comment);\n            xmlWriter.createTextElement(testElem, 'test-type', item.testtype);\n            let config = xmlDoc.createElementNS(xmlns, \"test-configuration\");\n            testElem.appendChild(config);\n            let filerefs = xmlDoc.createElementNS(xmlns, \"filerefs\");\n            config.appendChild(filerefs);\n            item.filerefs.forEach(writeFileref);\n            // remove filerefs is no fileref available\n            let childs = filerefs.getElementsByTagName('fileref');\n            if (childs.length === 0) {\n                config.removeChild(filerefs);\n            }\n\n            tests.appendChild(testElem);\n            if (item.configItem) {\n                console.log('*** item.configItem.onWriteXml');\n\n                // alert('config write xml');\n                item.configItem.onWriteXml(item, config, xmlDoc, xmlWriter, task);\n            }\n        }\n\n        function writeGradingTest(item, index) {\n            let testElem = xmlDoc.createElementNS(xmlns, \"test-ref\");\n            testElem.setAttribute(\"weight\", item.weight);\n            testElem.setAttribute(\"ref\", item.id);\n            gradingRoot.appendChild(testElem);\n        }\n\n        function writeFileRestriction(item, index) {\n            //let regexp = xmlWriter.createTextElement(submission, \"regexp-restriction\", this.filenameRegExpSubmission);\n            //submission.appendChild(regexp);\n            // regexp.setAttribute(\"mime-type-regexp\", this.mimeTypeRegExpSubmission);\n\n\n            let fileElem = //xmlDoc.createElementNS(xmlns, \"file-restriction\");\n            xmlWriter.createOptionalTextElement(fileRestrictions, 'file-restriction', item.restriction, xmlns);\n            if (!item.required) // optional, defaults to true\n                fileElem.setAttribute(\"required\", item.required);\n\n            if (item.format) // optional, defaults to none\n                fileElem.setAttribute(\"pattern-format\", item.format);\n\n            //fileRestrictions.appendChild(fileElem);\n        }\n\n\n        try {\n\n/*            if (topLevelDoc) {\n                xmlDoc = topLevelDoc;\n                task = xmlDoc.createElementNS(xmlns, \"task\");\n                rootNode.appendChild(task);\n            }\n            else {*/\n                xmlDoc = document.implementation.createDocument(xmlns, \"task\", null);\n                task = xmlDoc.documentElement;\n            //}\n\n            task.setAttribute(\"lang\", this.lang);\n            task.setAttribute(\"uuid\", this.uuid);\n            // task.setAttribute(\"uuid\", generateUUID());// this.uuid);\n            //taskeditorconfig.writeNamespaces(task);\n\n            xmlWriter = new XmlWriter(xmlDoc, xmlns);\n\n            xmlWriter.createTextElement(task, 'title', this.title);\n            xmlWriter.createCDataElement(task, 'description', this.description);\n            xmlWriter.createOptionalCDataElement(task, 'internal-description', this.comment);\n            let proglang = xmlWriter.createTextElement(task, 'proglang', this.proglang);\n            proglang.setAttribute(\"version\", this.proglangVersion);\n\n            fileRestrictions = xmlDoc.createElementNS(xmlns, \"submission-restrictions\");\n            if (this.sizeSubmission)\n                fileRestrictions.setAttribute(\"max-size\", this.sizeSubmission);\n            task.appendChild(fileRestrictions);\n            this.fileRestrictions.forEach(writeFileRestriction);\n\n            files = xmlDoc.createElementNS(xmlns, \"files\");\n            task.appendChild(files);\n            writeCodeSkeleton(this, 'codeskeleton');\n            this.files.forEach(writeFile);\n\n            modelsolutions = xmlDoc.createElementNS(xmlns, \"model-solutions\");\n            task.appendChild(modelsolutions);\n            this.modelsolutions.forEach(writeModelSolution);\n\n            tests = xmlDoc.createElementNS(xmlns, \"tests\");\n            task.appendChild(tests);\n            const length = this.tests.length;\n            this.tests.forEach(writeTest);\n\n            // grading-hints\n            let gradinghints = xmlDoc.createElementNS(xmlns, \"grading-hints\");\n            task.appendChild(gradinghints);\n            gradingRoot = xmlDoc.createElementNS(xmlns, \"root\");\n            gradingRoot.setAttribute(\"function\", \"sum\");\n            gradinghints.appendChild(gradingRoot);\n            this.tests.forEach(writeGradingTest);\n\n            let metadata = xmlDoc.createElementNS(xmlns, \"meta-data\");\n            task.appendChild(metadata);\n///            taskeditorconfig.writeXmlExtra(metadata, xmlDoc, xmlWriter);\n            //xmlWriter.createTextElement(metadata, 'praktomat:allowed-upload-filename-mimetypes', '(text/.*)');\n\n            let serializer = new XMLSerializer();\n            let result = serializer.serializeToString (xmlDoc);\n\n            if ((result.substring(0, 5) !== \"<?xml\")){\n                result = '<?xml version=\"1.0\"?>' + result;\n                // result = \"<?xml version='1.0' encoding='UTF-8'?>\" + result;\n            }\n\n            let xsds = [ 'xsd/proforma.xsd' ];\n            // do not add all xsds from configuration because not all of them may be used\n            // resulting in an error message\n            xsds = xsds.concat(taskeditorconfig.xsds);\n\n/*\n            if (!topLevelDoc) { // do not validate for XML part\n                // validate output\n                xsds.forEach(function (xsd_file, index) {\n                    $.get(xsd_file, function (data, textStatus, jqXHR) {      // read XSD schema\n                        const valid = xmllint.validateXML({xml: result, schema: jqXHR.responseText});\n                        if (valid.errors !== null) {                                // does not conform to schema\n                            //alert(xsd_file);\n                            setErrorMessage(\"Errors in XSD-Validation \" + xsd_file + \":\");\n                            valid.errors.some(function (error, index) {\n                                setErrorMessage(error);\n                                return index > 15;\n                            })\n                        }\n                    }).fail(function (jqXHR, textStatus, errorThrown) {\n                        setErrorMessage(\"XSD-Schema \" + xsd_file + \" not found.\", errorThrown);\n                    });\n                });\n            }\n*/\n            return result;\n        } catch (err){\n            setErrorMessage(\"Error creating task xml file.\", err);\n            return '';\n        }\n    }\n}"],"names":["T_LMS_USAGE","DISPLAY","DOWNLOAD","EDIT","T_VISIBLE","YES","NO","DELAYED","POSIX","NONE","XmlReader","constructor","xmlText","xmlDoc","DOMParser","parseFromString","this","evaluate","alert","defaultns","lookupNamespaceURI","rootNode","nsResolver","prefix","taskeditorconfig","resolveNamespace","setRootNode","node","readSingleNode","xpath","contextNode","console","error","XPathResult","UNORDERED_NODE_ITERATOR_TYPE","iterateNext","readSingleText","defaultValue","nodes","FIRST_ORDERED_NODE_TYPE","singleNodeValue","textContent","trim","readNodes","XmlWriter","ns","createCDataElement","tag","value","undefined","newTag","createElementNS","appendChild","createCDATASection","createTextElement","cdata","SyntaxError","createTextNode","createOptionalTextElement","createOptionalCDataElement","TaskFileRef","id","refid","TaskFile","filename","usedByGrader","usageInLms","visible","filetype","comment","content","binary","TaskFileRestriction","required","format","restriction","TaskModelSolution","description","filerefs","TaskTest","title","testtype","writeCallback","uiElement","framework","proglang","proglangVersion","parentuuid","uuid","lang","sizeSubmission","filenameRegExpSubmission","codeskeleton","fileRestrictions","files","modelsolutions","tests","gradinghints","findFilenameForId","forEach","item","readTestConfig","xmlfile","testid","configItem","context","xmlReader","textnode","Error","configNodeNode","onReadXml","err","readXmlVersion101","template_id","template_referenced","readFileRefs","element","thisNode","visibility","task","fileRefIterator","fileRefNode","counter","fileRef","iterator","taskfile","modelSolution","test","configIterator","readXmlVersion2","editCounter","nodeName","filecontent","encoded","Uint8Array","from","atob","c","charCodeAt","mimetype","getMimeType","fileObject","FileStorage","setSize","length","configNode","toLowerCase","unitNode","gradingfunction","weight","readXml","writeXml","topLevelDoc","log","gradingRoot","xmlWriter","xmlns","document","implementation","createDocument","documentElement","setAttribute","index","fileElem","fileContentElem","writeCodeSkeleton","msElem","file","fileref","getElementsByTagName","removeChild","testElem","config","onWriteXml","metadata","result","XMLSerializer","serializeToString","substring","xsds","concat"],"mappings":"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"}